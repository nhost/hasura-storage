// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(c *gin.Context)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(c *gin.Context, id string)
	// Download file
	// (GET /files/{id})
	GetFile(c *gin.Context, id string, params GetFileParams)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(c *gin.Context, id string, params GetFileMetadataHeadersParams)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(c *gin.Context, id string)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(c *gin.Context, id string)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetPresignedURLContents(c *gin.Context, id string, params GetPresignedURLContentsParams)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(c *gin.Context)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(c *gin.Context)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(c *gin.Context)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(c *gin.Context)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(c *gin.Context)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(c *gin.Context)
	// Get service version information
	// (GET /version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadFiles operation middleware
func (siw *ServerInterfaceWrapper) UploadFiles(c *gin.Context) {

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadFiles(c)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteFile(c, id)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFile(c, id, params)
}

// GetFileMetadataHeaders operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadataHeaders(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileMetadataHeadersParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileMetadataHeaders(c, id, params)
}

// ReplaceFile operation middleware
func (siw *ServerInterfaceWrapper) ReplaceFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReplaceFile(c, id)
}

// GetFilePresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetFilePresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFilePresignedURL(c, id)
}

// GetPresignedURLContents operation middleware
func (siw *ServerInterfaceWrapper) GetPresignedURLContents(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPresignedURLContentsParams

	// ------------- Required query parameter "X-Amz-Algorithm" -------------

	if paramValue := c.Query("X-Amz-Algorithm"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Algorithm is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Algorithm", c.Request.URL.Query(), &params.XAmzAlgorithm)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Algorithm: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Credential" -------------

	if paramValue := c.Query("X-Amz-Credential"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Credential is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Credential", c.Request.URL.Query(), &params.XAmzCredential)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Credential: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Date" -------------

	if paramValue := c.Query("X-Amz-Date"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Date is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Date", c.Request.URL.Query(), &params.XAmzDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Expires" -------------

	if paramValue := c.Query("X-Amz-Expires"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Expires is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Expires", c.Request.URL.Query(), &params.XAmzExpires)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Expires: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Signature" -------------

	if paramValue := c.Query("X-Amz-Signature"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Signature is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Signature", c.Request.URL.Query(), &params.XAmzSignature)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Signature: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-SignedHeaders" -------------

	if paramValue := c.Query("X-Amz-SignedHeaders"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-SignedHeaders is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-SignedHeaders", c.Request.URL.Query(), &params.XAmzSignedHeaders)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-SignedHeaders: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Checksum-Mode" -------------

	if paramValue := c.Query("X-Amz-Checksum-Mode"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Checksum-Mode is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Checksum-Mode", c.Request.URL.Query(), &params.XAmzChecksumMode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Checksum-Mode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "x-id" -------------

	if paramValue := c.Query("x-id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument x-id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "x-id", c.Request.URL.Query(), &params.XId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter x-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPresignedURLContents(c, id, params)
}

// GetOpenAPISpec operation middleware
func (siw *ServerInterfaceWrapper) GetOpenAPISpec(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenAPISpec(c)
}

// DeleteBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBrokenMetadata(c)
}

// DeleteOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) DeleteOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteOrphanedFiles(c)
}

// ListBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) ListBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListBrokenMetadata(c)
}

// ListFilesNotUploaded operation middleware
func (siw *ServerInterfaceWrapper) ListFilesNotUploaded(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListFilesNotUploaded(c)
}

// ListOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) ListOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListOrphanedFiles(c)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/files/", wrapper.UploadFiles)
	router.DELETE(options.BaseURL+"/files/:id", wrapper.DeleteFile)
	router.GET(options.BaseURL+"/files/:id", wrapper.GetFile)
	router.HEAD(options.BaseURL+"/files/:id", wrapper.GetFileMetadataHeaders)
	router.PUT(options.BaseURL+"/files/:id", wrapper.ReplaceFile)
	router.GET(options.BaseURL+"/files/:id/presignedurl", wrapper.GetFilePresignedURL)
	router.GET(options.BaseURL+"/files/:id/presignedurl/contents", wrapper.GetPresignedURLContents)
	router.GET(options.BaseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.POST(options.BaseURL+"/ops/delete-broken-metadata", wrapper.DeleteBrokenMetadata)
	router.POST(options.BaseURL+"/ops/delete-orphans", wrapper.DeleteOrphanedFiles)
	router.POST(options.BaseURL+"/ops/list-broken-metadata", wrapper.ListBrokenMetadata)
	router.POST(options.BaseURL+"/ops/list-not-uploaded", wrapper.ListFilesNotUploaded)
	router.POST(options.BaseURL+"/ops/list-orphans", wrapper.ListOrphanedFiles)
	router.GET(options.BaseURL+"/version", wrapper.GetVersion)
}

type UploadFilesRequestObject struct {
	Body *multipart.Reader
}

type UploadFilesResponseObject interface {
	VisitUploadFilesResponse(w http.ResponseWriter) error
}

type UploadFiles201JSONResponse struct {
	// ProcessedFiles List of successfully processed files with their metadata.
	ProcessedFiles []FileMetadata `json:"processedFiles"`
}

func (response UploadFiles201JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadFilesdefaultJSONResponse struct {
	Body       ErrorResponseWithProcessedFiles
	StatusCode int
}

func (response UploadFilesdefaultJSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteFileRequestObject struct {
	Id string `json:"id"`
}

type DeleteFileResponseObject interface {
	VisitDeleteFileResponse(w http.ResponseWriter) error
}

type DeleteFile204Response struct {
}

func (response DeleteFile204Response) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteFile400JSONResponse ErrorResponse

func (response DeleteFile400JSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetFileRequestObject struct {
	Id     string `json:"id"`
	Params GetFileParams
}

type GetFileResponseObject interface {
	VisitGetFileResponse(w http.ResponseWriter) error
}

type GetFile200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile200ResponseHeaders
	ContentLength int64
}

func (response GetFile200ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile206ResponseHeaders
	ContentLength int64
}

func (response GetFile206ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile304Response struct {
	Headers GetFile304ResponseHeaders
}

func (response GetFile304Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFile412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile412Response struct {
	Headers GetFile412ResponseHeaders
}

func (response GetFile412Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFiledefaultResponseHeaders struct {
	XError string
}

type GetFiledefaultResponse struct {
	Headers GetFiledefaultResponseHeaders

	StatusCode int
}

func (response GetFiledefaultResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetFileMetadataHeadersRequestObject struct {
	Id     string `json:"id"`
	Params GetFileMetadataHeadersParams
}

type GetFileMetadataHeadersResponseObject interface {
	VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error
}

type GetFileMetadataHeaders200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentLength      int
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileMetadataHeaders200Response struct {
	Headers GetFileMetadataHeaders200ResponseHeaders
}

func (response GetFileMetadataHeaders200Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)
	return nil
}

type GetFileMetadataHeaders304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders304Response struct {
	Headers GetFileMetadataHeaders304ResponseHeaders
}

func (response GetFileMetadataHeaders304Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileMetadataHeaders412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders412Response struct {
	Headers GetFileMetadataHeaders412ResponseHeaders
}

func (response GetFileMetadataHeaders412Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileMetadataHeadersdefaultResponseHeaders struct {
	XError string
}

type GetFileMetadataHeadersdefaultResponse struct {
	Headers GetFileMetadataHeadersdefaultResponseHeaders

	StatusCode int
}

func (response GetFileMetadataHeadersdefaultResponse) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type ReplaceFileRequestObject struct {
	Id   string `json:"id"`
	Body *multipart.Reader
}

type ReplaceFileResponseObject interface {
	VisitReplaceFileResponse(w http.ResponseWriter) error
}

type ReplaceFile200JSONResponse FileMetadata

func (response ReplaceFile200JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ReplaceFiledefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ReplaceFiledefaultJSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFilePresignedURLRequestObject struct {
	Id string `json:"id"`
}

type GetFilePresignedURLResponseObject interface {
	VisitGetFilePresignedURLResponse(w http.ResponseWriter) error
}

type GetFilePresignedURL200JSONResponse PresignedURLResponse

func (response GetFilePresignedURL200JSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetFilePresignedURLdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetFilePresignedURLdefaultJSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetPresignedURLContentsRequestObject struct {
	Id     string `json:"id"`
	Params GetPresignedURLContentsParams
}

type GetPresignedURLContentsResponseObject interface {
	VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error
}

type GetPresignedURLContents200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetPresignedURLContents200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetPresignedURLContents200ResponseHeaders
	ContentLength int64
}

func (response GetPresignedURLContents200ApplicationoctetStreamResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetPresignedURLContents206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetPresignedURLContents206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetPresignedURLContents206ResponseHeaders
	ContentLength int64
}

func (response GetPresignedURLContents206ApplicationoctetStreamResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetPresignedURLContents304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetPresignedURLContents304Response struct {
	Headers GetPresignedURLContents304ResponseHeaders
}

func (response GetPresignedURLContents304Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetPresignedURLContents412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetPresignedURLContents412Response struct {
	Headers GetPresignedURLContents412ResponseHeaders
}

func (response GetPresignedURLContents412Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetPresignedURLContentsdefaultResponseHeaders struct {
	XError string
}

type GetPresignedURLContentsdefaultResponse struct {
	Headers GetPresignedURLContentsdefaultResponseHeaders

	StatusCode int
}

func (response GetPresignedURLContentsdefaultResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetOpenAPISpecRequestObject struct {
}

type GetOpenAPISpecResponseObject interface {
	VisitGetOpenAPISpecResponse(w http.ResponseWriter) error
}

type GetOpenAPISpec200ApplicationxYamlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetOpenAPISpec200ApplicationxYamlResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/x-yaml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBrokenMetadataRequestObject struct {
}

type DeleteBrokenMetadataResponseObject interface {
	VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error
}

type DeleteBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response DeleteBrokenMetadata200JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBrokenMetadata400JSONResponse ErrorResponse

func (response DeleteBrokenMetadata400JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFilesRequestObject struct {
}

type DeleteOrphanedFilesResponseObject interface {
	VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error
}

type DeleteOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response DeleteOrphanedFiles200JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFiles400JSONResponse ErrorResponse

func (response DeleteOrphanedFiles400JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadataRequestObject struct {
}

type ListBrokenMetadataResponseObject interface {
	VisitListBrokenMetadataResponse(w http.ResponseWriter) error
}

type ListBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListBrokenMetadata200JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadata400JSONResponse ErrorResponse

func (response ListBrokenMetadata400JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploadedRequestObject struct {
}

type ListFilesNotUploadedResponseObject interface {
	VisitListFilesNotUploadedResponse(w http.ResponseWriter) error
}

type ListFilesNotUploaded200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListFilesNotUploaded200JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploaded400JSONResponse ErrorResponse

func (response ListFilesNotUploaded400JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFilesRequestObject struct {
}

type ListOrphanedFilesResponseObject interface {
	VisitListOrphanedFilesResponse(w http.ResponseWriter) error
}

type ListOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response ListOrphanedFiles200JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFiles400JSONResponse ErrorResponse

func (response ListOrphanedFiles400JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse VersionInformation

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(ctx context.Context, request UploadFilesRequestObject) (UploadFilesResponseObject, error)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(ctx context.Context, request DeleteFileRequestObject) (DeleteFileResponseObject, error)
	// Download file
	// (GET /files/{id})
	GetFile(ctx context.Context, request GetFileRequestObject) (GetFileResponseObject, error)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(ctx context.Context, request GetFileMetadataHeadersRequestObject) (GetFileMetadataHeadersResponseObject, error)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(ctx context.Context, request ReplaceFileRequestObject) (ReplaceFileResponseObject, error)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(ctx context.Context, request GetFilePresignedURLRequestObject) (GetFilePresignedURLResponseObject, error)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetPresignedURLContents(ctx context.Context, request GetPresignedURLContentsRequestObject) (GetPresignedURLContentsResponseObject, error)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx context.Context, request GetOpenAPISpecRequestObject) (GetOpenAPISpecResponseObject, error)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(ctx context.Context, request DeleteBrokenMetadataRequestObject) (DeleteBrokenMetadataResponseObject, error)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(ctx context.Context, request DeleteOrphanedFilesRequestObject) (DeleteOrphanedFilesResponseObject, error)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(ctx context.Context, request ListBrokenMetadataRequestObject) (ListBrokenMetadataResponseObject, error)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(ctx context.Context, request ListFilesNotUploadedRequestObject) (ListFilesNotUploadedResponseObject, error)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(ctx context.Context, request ListOrphanedFilesRequestObject) (ListOrphanedFilesResponseObject, error)
	// Get service version information
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadFiles operation middleware
func (sh *strictHandler) UploadFiles(ctx *gin.Context) {
	var request UploadFilesRequestObject

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadFiles(ctx, request.(UploadFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadFilesResponseObject); ok {
		if err := validResponse.VisitUploadFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFile operation middleware
func (sh *strictHandler) DeleteFile(ctx *gin.Context, id string) {
	var request DeleteFileRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFile(ctx, request.(DeleteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteFileResponseObject); ok {
		if err := validResponse.VisitDeleteFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFile operation middleware
func (sh *strictHandler) GetFile(ctx *gin.Context, id string, params GetFileParams) {
	var request GetFileRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFile(ctx, request.(GetFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileResponseObject); ok {
		if err := validResponse.VisitGetFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileMetadataHeaders operation middleware
func (sh *strictHandler) GetFileMetadataHeaders(ctx *gin.Context, id string, params GetFileMetadataHeadersParams) {
	var request GetFileMetadataHeadersRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileMetadataHeaders(ctx, request.(GetFileMetadataHeadersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileMetadataHeaders")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileMetadataHeadersResponseObject); ok {
		if err := validResponse.VisitGetFileMetadataHeadersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReplaceFile operation middleware
func (sh *strictHandler) ReplaceFile(ctx *gin.Context, id string) {
	var request ReplaceFileRequestObject

	request.Id = id

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ReplaceFile(ctx, request.(ReplaceFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReplaceFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ReplaceFileResponseObject); ok {
		if err := validResponse.VisitReplaceFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFilePresignedURL operation middleware
func (sh *strictHandler) GetFilePresignedURL(ctx *gin.Context, id string) {
	var request GetFilePresignedURLRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFilePresignedURL(ctx, request.(GetFilePresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFilePresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFilePresignedURLResponseObject); ok {
		if err := validResponse.VisitGetFilePresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPresignedURLContents operation middleware
func (sh *strictHandler) GetPresignedURLContents(ctx *gin.Context, id string, params GetPresignedURLContentsParams) {
	var request GetPresignedURLContentsRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPresignedURLContents(ctx, request.(GetPresignedURLContentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPresignedURLContents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPresignedURLContentsResponseObject); ok {
		if err := validResponse.VisitGetPresignedURLContentsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOpenAPISpec operation middleware
func (sh *strictHandler) GetOpenAPISpec(ctx *gin.Context) {
	var request GetOpenAPISpecRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetOpenAPISpec(ctx, request.(GetOpenAPISpecRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOpenAPISpec")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetOpenAPISpecResponseObject); ok {
		if err := validResponse.VisitGetOpenAPISpecResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBrokenMetadata operation middleware
func (sh *strictHandler) DeleteBrokenMetadata(ctx *gin.Context) {
	var request DeleteBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBrokenMetadata(ctx, request.(DeleteBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitDeleteBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteOrphanedFiles operation middleware
func (sh *strictHandler) DeleteOrphanedFiles(ctx *gin.Context) {
	var request DeleteOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteOrphanedFiles(ctx, request.(DeleteOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitDeleteOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBrokenMetadata operation middleware
func (sh *strictHandler) ListBrokenMetadata(ctx *gin.Context) {
	var request ListBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListBrokenMetadata(ctx, request.(ListBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitListBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFilesNotUploaded operation middleware
func (sh *strictHandler) ListFilesNotUploaded(ctx *gin.Context) {
	var request ListFilesNotUploadedRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListFilesNotUploaded(ctx, request.(ListFilesNotUploadedRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFilesNotUploaded")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListFilesNotUploadedResponseObject); ok {
		if err := validResponse.VisitListFilesNotUploadedResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListOrphanedFiles operation middleware
func (sh *strictHandler) ListOrphanedFiles(ctx *gin.Context) {
	var request ListOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListOrphanedFiles(ctx, request.(ListOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitListOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(ctx *gin.Context) {
	var request GetVersionRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

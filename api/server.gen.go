// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(c *gin.Context)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(c *gin.Context, id string)
	// Download file
	// (GET /files/{id})
	GetFile(c *gin.Context, id string, params GetFileParams)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(c *gin.Context, id string, params GetFileMetadataHeadersParams)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(c *gin.Context, id string)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(c *gin.Context, id string)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetFileWithPresignedURL(c *gin.Context, id string, params GetFileWithPresignedURLParams)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(c *gin.Context)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(c *gin.Context)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(c *gin.Context)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(c *gin.Context)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(c *gin.Context)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(c *gin.Context)
	// Get service version information
	// (GET /version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadFiles operation middleware
func (siw *ServerInterfaceWrapper) UploadFiles(c *gin.Context) {

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadFiles(c)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteFile(c, id)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFile(c, id, params)
}

// GetFileMetadataHeaders operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadataHeaders(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileMetadataHeadersParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileMetadataHeaders(c, id, params)
}

// ReplaceFile operation middleware
func (siw *ServerInterfaceWrapper) ReplaceFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReplaceFile(c, id)
}

// GetFilePresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetFilePresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFilePresignedURL(c, id)
}

// GetFileWithPresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetFileWithPresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileWithPresignedURLParams

	// ------------- Required query parameter "X-Amz-Algorithm" -------------

	if paramValue := c.Query("X-Amz-Algorithm"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Algorithm is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Algorithm", c.Request.URL.Query(), &params.XAmzAlgorithm)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Algorithm: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Credential" -------------

	if paramValue := c.Query("X-Amz-Credential"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Credential is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Credential", c.Request.URL.Query(), &params.XAmzCredential)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Credential: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Date" -------------

	if paramValue := c.Query("X-Amz-Date"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Date is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Date", c.Request.URL.Query(), &params.XAmzDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Expires" -------------

	if paramValue := c.Query("X-Amz-Expires"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Expires is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Expires", c.Request.URL.Query(), &params.XAmzExpires)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Expires: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Signature" -------------

	if paramValue := c.Query("X-Amz-Signature"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Signature is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Signature", c.Request.URL.Query(), &params.XAmzSignature)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Signature: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-SignedHeaders" -------------

	if paramValue := c.Query("X-Amz-SignedHeaders"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-SignedHeaders is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-SignedHeaders", c.Request.URL.Query(), &params.XAmzSignedHeaders)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-SignedHeaders: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Checksum-Mode" -------------

	if paramValue := c.Query("X-Amz-Checksum-Mode"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Checksum-Mode is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Checksum-Mode", c.Request.URL.Query(), &params.XAmzChecksumMode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Checksum-Mode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "x-id" -------------

	if paramValue := c.Query("x-id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument x-id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "x-id", c.Request.URL.Query(), &params.XId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter x-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileWithPresignedURL(c, id, params)
}

// GetOpenAPISpec operation middleware
func (siw *ServerInterfaceWrapper) GetOpenAPISpec(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenAPISpec(c)
}

// DeleteBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBrokenMetadata(c)
}

// DeleteOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) DeleteOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteOrphanedFiles(c)
}

// ListBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) ListBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListBrokenMetadata(c)
}

// ListFilesNotUploaded operation middleware
func (siw *ServerInterfaceWrapper) ListFilesNotUploaded(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListFilesNotUploaded(c)
}

// ListOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) ListOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListOrphanedFiles(c)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/files/", wrapper.UploadFiles)
	router.DELETE(options.BaseURL+"/files/:id", wrapper.DeleteFile)
	router.GET(options.BaseURL+"/files/:id", wrapper.GetFile)
	router.HEAD(options.BaseURL+"/files/:id", wrapper.GetFileMetadataHeaders)
	router.PUT(options.BaseURL+"/files/:id", wrapper.ReplaceFile)
	router.GET(options.BaseURL+"/files/:id/presignedurl", wrapper.GetFilePresignedURL)
	router.GET(options.BaseURL+"/files/:id/presignedurl/contents", wrapper.GetFileWithPresignedURL)
	router.GET(options.BaseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.POST(options.BaseURL+"/ops/delete-broken-metadata", wrapper.DeleteBrokenMetadata)
	router.POST(options.BaseURL+"/ops/delete-orphans", wrapper.DeleteOrphanedFiles)
	router.POST(options.BaseURL+"/ops/list-broken-metadata", wrapper.ListBrokenMetadata)
	router.POST(options.BaseURL+"/ops/list-not-uploaded", wrapper.ListFilesNotUploaded)
	router.POST(options.BaseURL+"/ops/list-orphans", wrapper.ListOrphanedFiles)
	router.GET(options.BaseURL+"/version", wrapper.GetVersion)
}

type UploadFilesRequestObject struct {
	Body *multipart.Reader
}

type UploadFilesResponseObject interface {
	VisitUploadFilesResponse(w http.ResponseWriter) error
}

type UploadFiles201JSONResponse struct {
	// ProcessedFiles List of successfully processed files with their metadata.
	ProcessedFiles []FileMetadata `json:"processedFiles"`
}

func (response UploadFiles201JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadFilesdefaultJSONResponse struct {
	Body       ErrorResponseWithProcessedFiles
	StatusCode int
}

func (response UploadFilesdefaultJSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteFileRequestObject struct {
	Id string `json:"id"`
}

type DeleteFileResponseObject interface {
	VisitDeleteFileResponse(w http.ResponseWriter) error
}

type DeleteFile204Response struct {
}

func (response DeleteFile204Response) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteFiledefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteFiledefaultJSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFileRequestObject struct {
	Id     string `json:"id"`
	Params GetFileParams
}

type GetFileResponseObject interface {
	VisitGetFileResponse(w http.ResponseWriter) error
}

type GetFile200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile200ResponseHeaders
	ContentLength int64
}

func (response GetFile200ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile206ResponseHeaders
	ContentLength int64
}

func (response GetFile206ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile304Response struct {
	Headers GetFile304ResponseHeaders
}

func (response GetFile304Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFile412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile412Response struct {
	Headers GetFile412ResponseHeaders
}

func (response GetFile412Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFiledefaultResponseHeaders struct {
	XError string
}

type GetFiledefaultResponse struct {
	Headers GetFiledefaultResponseHeaders

	StatusCode int
}

func (response GetFiledefaultResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetFileMetadataHeadersRequestObject struct {
	Id     string `json:"id"`
	Params GetFileMetadataHeadersParams
}

type GetFileMetadataHeadersResponseObject interface {
	VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error
}

type GetFileMetadataHeaders200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentLength      int
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileMetadataHeaders200Response struct {
	Headers GetFileMetadataHeaders200ResponseHeaders
}

func (response GetFileMetadataHeaders200Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)
	return nil
}

type GetFileMetadataHeaders304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders304Response struct {
	Headers GetFileMetadataHeaders304ResponseHeaders
}

func (response GetFileMetadataHeaders304Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileMetadataHeaders412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders412Response struct {
	Headers GetFileMetadataHeaders412ResponseHeaders
}

func (response GetFileMetadataHeaders412Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileMetadataHeadersdefaultResponseHeaders struct {
	XError string
}

type GetFileMetadataHeadersdefaultResponse struct {
	Headers GetFileMetadataHeadersdefaultResponseHeaders

	StatusCode int
}

func (response GetFileMetadataHeadersdefaultResponse) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type ReplaceFileRequestObject struct {
	Id   string `json:"id"`
	Body *multipart.Reader
}

type ReplaceFileResponseObject interface {
	VisitReplaceFileResponse(w http.ResponseWriter) error
}

type ReplaceFile200JSONResponse FileMetadata

func (response ReplaceFile200JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ReplaceFiledefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ReplaceFiledefaultJSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFilePresignedURLRequestObject struct {
	Id string `json:"id"`
}

type GetFilePresignedURLResponseObject interface {
	VisitGetFilePresignedURLResponse(w http.ResponseWriter) error
}

type GetFilePresignedURL200JSONResponse PresignedURLResponse

func (response GetFilePresignedURL200JSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetFilePresignedURLdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetFilePresignedURLdefaultJSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFileWithPresignedURLRequestObject struct {
	Id     string `json:"id"`
	Params GetFileWithPresignedURLParams
}

type GetFileWithPresignedURLResponseObject interface {
	VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error
}

type GetFileWithPresignedURL200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileWithPresignedURL200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFileWithPresignedURL200ResponseHeaders
	ContentLength int64
}

func (response GetFileWithPresignedURL200ApplicationoctetStreamResponse) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFileWithPresignedURL206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileWithPresignedURL206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFileWithPresignedURL206ResponseHeaders
	ContentLength int64
}

func (response GetFileWithPresignedURL206ApplicationoctetStreamResponse) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFileWithPresignedURL304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileWithPresignedURL304Response struct {
	Headers GetFileWithPresignedURL304ResponseHeaders
}

func (response GetFileWithPresignedURL304Response) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileWithPresignedURL412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileWithPresignedURL412Response struct {
	Headers GetFileWithPresignedURL412ResponseHeaders
}

func (response GetFileWithPresignedURL412Response) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileWithPresignedURLdefaultResponseHeaders struct {
	XError string
}

type GetFileWithPresignedURLdefaultResponse struct {
	Headers GetFileWithPresignedURLdefaultResponseHeaders

	StatusCode int
}

func (response GetFileWithPresignedURLdefaultResponse) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetOpenAPISpecRequestObject struct {
}

type GetOpenAPISpecResponseObject interface {
	VisitGetOpenAPISpecResponse(w http.ResponseWriter) error
}

type GetOpenAPISpec200ApplicationxYamlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetOpenAPISpec200ApplicationxYamlResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/x-yaml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetOpenAPISpecdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOpenAPISpecdefaultJSONResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBrokenMetadataRequestObject struct {
}

type DeleteBrokenMetadataResponseObject interface {
	VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error
}

type DeleteBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response DeleteBrokenMetadata200JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBrokenMetadatadefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteBrokenMetadatadefaultJSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteOrphanedFilesRequestObject struct {
}

type DeleteOrphanedFilesResponseObject interface {
	VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error
}

type DeleteOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response DeleteOrphanedFiles200JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFilesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteOrphanedFilesdefaultJSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListBrokenMetadataRequestObject struct {
}

type ListBrokenMetadataResponseObject interface {
	VisitListBrokenMetadataResponse(w http.ResponseWriter) error
}

type ListBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListBrokenMetadata200JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadatadefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListBrokenMetadatadefaultJSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListFilesNotUploadedRequestObject struct {
}

type ListFilesNotUploadedResponseObject interface {
	VisitListFilesNotUploadedResponse(w http.ResponseWriter) error
}

type ListFilesNotUploaded200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListFilesNotUploaded200JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploadeddefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListFilesNotUploadeddefaultJSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListOrphanedFilesRequestObject struct {
}

type ListOrphanedFilesResponseObject interface {
	VisitListOrphanedFilesResponse(w http.ResponseWriter) error
}

type ListOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response ListOrphanedFiles200JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFilesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListOrphanedFilesdefaultJSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse VersionInformation

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetVersiondefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetVersiondefaultJSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(ctx context.Context, request UploadFilesRequestObject) (UploadFilesResponseObject, error)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(ctx context.Context, request DeleteFileRequestObject) (DeleteFileResponseObject, error)
	// Download file
	// (GET /files/{id})
	GetFile(ctx context.Context, request GetFileRequestObject) (GetFileResponseObject, error)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(ctx context.Context, request GetFileMetadataHeadersRequestObject) (GetFileMetadataHeadersResponseObject, error)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(ctx context.Context, request ReplaceFileRequestObject) (ReplaceFileResponseObject, error)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(ctx context.Context, request GetFilePresignedURLRequestObject) (GetFilePresignedURLResponseObject, error)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetFileWithPresignedURL(ctx context.Context, request GetFileWithPresignedURLRequestObject) (GetFileWithPresignedURLResponseObject, error)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx context.Context, request GetOpenAPISpecRequestObject) (GetOpenAPISpecResponseObject, error)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(ctx context.Context, request DeleteBrokenMetadataRequestObject) (DeleteBrokenMetadataResponseObject, error)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(ctx context.Context, request DeleteOrphanedFilesRequestObject) (DeleteOrphanedFilesResponseObject, error)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(ctx context.Context, request ListBrokenMetadataRequestObject) (ListBrokenMetadataResponseObject, error)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(ctx context.Context, request ListFilesNotUploadedRequestObject) (ListFilesNotUploadedResponseObject, error)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(ctx context.Context, request ListOrphanedFilesRequestObject) (ListOrphanedFilesResponseObject, error)
	// Get service version information
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadFiles operation middleware
func (sh *strictHandler) UploadFiles(ctx *gin.Context) {
	var request UploadFilesRequestObject

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadFiles(ctx, request.(UploadFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadFilesResponseObject); ok {
		if err := validResponse.VisitUploadFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFile operation middleware
func (sh *strictHandler) DeleteFile(ctx *gin.Context, id string) {
	var request DeleteFileRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFile(ctx, request.(DeleteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteFileResponseObject); ok {
		if err := validResponse.VisitDeleteFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFile operation middleware
func (sh *strictHandler) GetFile(ctx *gin.Context, id string, params GetFileParams) {
	var request GetFileRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFile(ctx, request.(GetFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileResponseObject); ok {
		if err := validResponse.VisitGetFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileMetadataHeaders operation middleware
func (sh *strictHandler) GetFileMetadataHeaders(ctx *gin.Context, id string, params GetFileMetadataHeadersParams) {
	var request GetFileMetadataHeadersRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileMetadataHeaders(ctx, request.(GetFileMetadataHeadersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileMetadataHeaders")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileMetadataHeadersResponseObject); ok {
		if err := validResponse.VisitGetFileMetadataHeadersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReplaceFile operation middleware
func (sh *strictHandler) ReplaceFile(ctx *gin.Context, id string) {
	var request ReplaceFileRequestObject

	request.Id = id

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ReplaceFile(ctx, request.(ReplaceFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReplaceFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ReplaceFileResponseObject); ok {
		if err := validResponse.VisitReplaceFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFilePresignedURL operation middleware
func (sh *strictHandler) GetFilePresignedURL(ctx *gin.Context, id string) {
	var request GetFilePresignedURLRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFilePresignedURL(ctx, request.(GetFilePresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFilePresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFilePresignedURLResponseObject); ok {
		if err := validResponse.VisitGetFilePresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileWithPresignedURL operation middleware
func (sh *strictHandler) GetFileWithPresignedURL(ctx *gin.Context, id string, params GetFileWithPresignedURLParams) {
	var request GetFileWithPresignedURLRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileWithPresignedURL(ctx, request.(GetFileWithPresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileWithPresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileWithPresignedURLResponseObject); ok {
		if err := validResponse.VisitGetFileWithPresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOpenAPISpec operation middleware
func (sh *strictHandler) GetOpenAPISpec(ctx *gin.Context) {
	var request GetOpenAPISpecRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetOpenAPISpec(ctx, request.(GetOpenAPISpecRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOpenAPISpec")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetOpenAPISpecResponseObject); ok {
		if err := validResponse.VisitGetOpenAPISpecResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBrokenMetadata operation middleware
func (sh *strictHandler) DeleteBrokenMetadata(ctx *gin.Context) {
	var request DeleteBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBrokenMetadata(ctx, request.(DeleteBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitDeleteBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteOrphanedFiles operation middleware
func (sh *strictHandler) DeleteOrphanedFiles(ctx *gin.Context) {
	var request DeleteOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteOrphanedFiles(ctx, request.(DeleteOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitDeleteOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBrokenMetadata operation middleware
func (sh *strictHandler) ListBrokenMetadata(ctx *gin.Context) {
	var request ListBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListBrokenMetadata(ctx, request.(ListBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitListBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFilesNotUploaded operation middleware
func (sh *strictHandler) ListFilesNotUploaded(ctx *gin.Context) {
	var request ListFilesNotUploadedRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListFilesNotUploaded(ctx, request.(ListFilesNotUploadedRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFilesNotUploaded")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListFilesNotUploadedResponseObject); ok {
		if err := validResponse.VisitListFilesNotUploadedResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListOrphanedFiles operation middleware
func (sh *strictHandler) ListOrphanedFiles(ctx *gin.Context) {
	var request ListOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListOrphanedFiles(ctx, request.(ListOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitListOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(ctx *gin.Context) {
	var request GetVersionRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

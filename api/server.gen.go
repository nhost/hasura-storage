// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(c *gin.Context)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(c *gin.Context, id string)
	// Download file
	// (GET /files/{id})
	GetFile(c *gin.Context, id string, params GetFileParams)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(c *gin.Context, id string, params GetFileMetadataHeadersParams)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(c *gin.Context, id string)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(c *gin.Context, id string)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetPresignedURLContents(c *gin.Context, id string, params GetPresignedURLContentsParams)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(c *gin.Context)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(c *gin.Context)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(c *gin.Context)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(c *gin.Context)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(c *gin.Context)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(c *gin.Context)
	// Get service version information
	// (GET /version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadFiles operation middleware
func (siw *ServerInterfaceWrapper) UploadFiles(c *gin.Context) {

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadFiles(c)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteFile(c, id)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFile(c, id, params)
}

// GetFileMetadataHeaders operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadataHeaders(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileMetadataHeadersParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileMetadataHeaders(c, id, params)
}

// ReplaceFile operation middleware
func (siw *ServerInterfaceWrapper) ReplaceFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReplaceFile(c, id)
}

// GetFilePresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetFilePresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFilePresignedURL(c, id)
}

// GetPresignedURLContents operation middleware
func (siw *ServerInterfaceWrapper) GetPresignedURLContents(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPresignedURLContentsParams

	// ------------- Required query parameter "X-Amz-Algorithm" -------------

	if paramValue := c.Query("X-Amz-Algorithm"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Algorithm is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Algorithm", c.Request.URL.Query(), &params.XAmzAlgorithm)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Algorithm: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Credential" -------------

	if paramValue := c.Query("X-Amz-Credential"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Credential is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Credential", c.Request.URL.Query(), &params.XAmzCredential)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Credential: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Date" -------------

	if paramValue := c.Query("X-Amz-Date"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Date is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Date", c.Request.URL.Query(), &params.XAmzDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Expires" -------------

	if paramValue := c.Query("X-Amz-Expires"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Expires is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Expires", c.Request.URL.Query(), &params.XAmzExpires)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Expires: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Signature" -------------

	if paramValue := c.Query("X-Amz-Signature"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Signature is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Signature", c.Request.URL.Query(), &params.XAmzSignature)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Signature: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-SignedHeaders" -------------

	if paramValue := c.Query("X-Amz-SignedHeaders"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-SignedHeaders is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-SignedHeaders", c.Request.URL.Query(), &params.XAmzSignedHeaders)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-SignedHeaders: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Checksum-Mode" -------------

	if paramValue := c.Query("X-Amz-Checksum-Mode"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Checksum-Mode is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Checksum-Mode", c.Request.URL.Query(), &params.XAmzChecksumMode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Checksum-Mode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "x-id" -------------

	if paramValue := c.Query("x-id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument x-id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "x-id", c.Request.URL.Query(), &params.XId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter x-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPresignedURLContents(c, id, params)
}

// GetOpenAPISpec operation middleware
func (siw *ServerInterfaceWrapper) GetOpenAPISpec(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenAPISpec(c)
}

// DeleteBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBrokenMetadata(c)
}

// DeleteOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) DeleteOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteOrphanedFiles(c)
}

// ListBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) ListBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListBrokenMetadata(c)
}

// ListFilesNotUploaded operation middleware
func (siw *ServerInterfaceWrapper) ListFilesNotUploaded(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListFilesNotUploaded(c)
}

// ListOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) ListOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListOrphanedFiles(c)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/files/", wrapper.UploadFiles)
	router.DELETE(options.BaseURL+"/files/:id", wrapper.DeleteFile)
	router.GET(options.BaseURL+"/files/:id", wrapper.GetFile)
	router.HEAD(options.BaseURL+"/files/:id", wrapper.GetFileMetadataHeaders)
	router.PUT(options.BaseURL+"/files/:id", wrapper.ReplaceFile)
	router.GET(options.BaseURL+"/files/:id/presignedurl", wrapper.GetFilePresignedURL)
	router.GET(options.BaseURL+"/files/:id/presignedurl/contents", wrapper.GetPresignedURLContents)
	router.GET(options.BaseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.POST(options.BaseURL+"/ops/delete-broken-metadata", wrapper.DeleteBrokenMetadata)
	router.POST(options.BaseURL+"/ops/delete-orphans", wrapper.DeleteOrphanedFiles)
	router.POST(options.BaseURL+"/ops/list-broken-metadata", wrapper.ListBrokenMetadata)
	router.POST(options.BaseURL+"/ops/list-not-uploaded", wrapper.ListFilesNotUploaded)
	router.POST(options.BaseURL+"/ops/list-orphans", wrapper.ListOrphanedFiles)
	router.GET(options.BaseURL+"/version", wrapper.GetVersion)
}

type UploadFilesRequestObject struct {
	Body *multipart.Reader
}

type UploadFilesResponseObject interface {
	VisitUploadFilesResponse(w http.ResponseWriter) error
}

type UploadFiles201JSONResponse struct {
	// ProcessedFiles List of successfully processed files with their metadata.
	ProcessedFiles []FileMetadata `json:"processedFiles"`
}

func (response UploadFiles201JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadFilesdefaultJSONResponse struct {
	Body       ErrorResponseWithProcessedFiles
	StatusCode int
}

func (response UploadFilesdefaultJSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteFileRequestObject struct {
	Id string `json:"id"`
}

type DeleteFileResponseObject interface {
	VisitDeleteFileResponse(w http.ResponseWriter) error
}

type DeleteFile204Response struct {
}

func (response DeleteFile204Response) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteFile400JSONResponse ErrorResponse

func (response DeleteFile400JSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetFileRequestObject struct {
	Id     string `json:"id"`
	Params GetFileParams
}

type GetFileResponseObject interface {
	VisitGetFileResponse(w http.ResponseWriter) error
}

type GetFile200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile200ResponseHeaders
	ContentLength int64
}

func (response GetFile200ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile206ResponseHeaders
	ContentLength int64
}

func (response GetFile206ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile304Response struct {
	Headers GetFile304ResponseHeaders
}

func (response GetFile304Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFile412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile412Response struct {
	Headers GetFile412ResponseHeaders
}

func (response GetFile412Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFiledefaultResponseHeaders struct {
	XError string
}

type GetFiledefaultResponse struct {
	Headers GetFiledefaultResponseHeaders

	StatusCode int
}

func (response GetFiledefaultResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetFileMetadataHeadersRequestObject struct {
	Id     string `json:"id"`
	Params GetFileMetadataHeadersParams
}

type GetFileMetadataHeadersResponseObject interface {
	VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error
}

type GetFileMetadataHeaders200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentLength      int
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileMetadataHeaders200Response struct {
	Headers GetFileMetadataHeaders200ResponseHeaders
}

func (response GetFileMetadataHeaders200Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)
	return nil
}

type GetFileMetadataHeaders304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders304Response struct {
	Headers GetFileMetadataHeaders304ResponseHeaders
}

func (response GetFileMetadataHeaders304Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileMetadataHeaders412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders412Response struct {
	Headers GetFileMetadataHeaders412ResponseHeaders
}

func (response GetFileMetadataHeaders412Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileMetadataHeadersdefaultResponseHeaders struct {
	XError string
}

type GetFileMetadataHeadersdefaultResponse struct {
	Headers GetFileMetadataHeadersdefaultResponseHeaders

	StatusCode int
}

func (response GetFileMetadataHeadersdefaultResponse) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type ReplaceFileRequestObject struct {
	Id   string `json:"id"`
	Body *multipart.Reader
}

type ReplaceFileResponseObject interface {
	VisitReplaceFileResponse(w http.ResponseWriter) error
}

type ReplaceFile200JSONResponse FileMetadata

func (response ReplaceFile200JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ReplaceFile400JSONResponse ErrorResponse

func (response ReplaceFile400JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetFilePresignedURLRequestObject struct {
	Id string `json:"id"`
}

type GetFilePresignedURLResponseObject interface {
	VisitGetFilePresignedURLResponse(w http.ResponseWriter) error
}

type GetFilePresignedURL200JSONResponse PresignedURLResponse

func (response GetFilePresignedURL200JSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetFilePresignedURLdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetFilePresignedURLdefaultJSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetPresignedURLContentsRequestObject struct {
	Id     string `json:"id"`
	Params GetPresignedURLContentsParams
}

type GetPresignedURLContentsResponseObject interface {
	VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error
}

type GetPresignedURLContents200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetPresignedURLContents200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetPresignedURLContents200ResponseHeaders
	ContentLength int64
}

func (response GetPresignedURLContents200ApplicationoctetStreamResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetPresignedURLContents206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetPresignedURLContents206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetPresignedURLContents206ResponseHeaders
	ContentLength int64
}

func (response GetPresignedURLContents206ApplicationoctetStreamResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetPresignedURLContents304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetPresignedURLContents304Response struct {
	Headers GetPresignedURLContents304ResponseHeaders
}

func (response GetPresignedURLContents304Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetPresignedURLContents412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetPresignedURLContents412Response struct {
	Headers GetPresignedURLContents412ResponseHeaders
}

func (response GetPresignedURLContents412Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetPresignedURLContentsdefaultResponseHeaders struct {
	XError string
}

type GetPresignedURLContentsdefaultResponse struct {
	Headers GetPresignedURLContentsdefaultResponseHeaders

	StatusCode int
}

func (response GetPresignedURLContentsdefaultResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetOpenAPISpecRequestObject struct {
}

type GetOpenAPISpecResponseObject interface {
	VisitGetOpenAPISpecResponse(w http.ResponseWriter) error
}

type GetOpenAPISpec200ApplicationxYamlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetOpenAPISpec200ApplicationxYamlResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/x-yaml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBrokenMetadataRequestObject struct {
}

type DeleteBrokenMetadataResponseObject interface {
	VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error
}

type DeleteBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response DeleteBrokenMetadata200JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBrokenMetadata400JSONResponse ErrorResponse

func (response DeleteBrokenMetadata400JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFilesRequestObject struct {
}

type DeleteOrphanedFilesResponseObject interface {
	VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error
}

type DeleteOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response DeleteOrphanedFiles200JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFiles400JSONResponse ErrorResponse

func (response DeleteOrphanedFiles400JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadataRequestObject struct {
}

type ListBrokenMetadataResponseObject interface {
	VisitListBrokenMetadataResponse(w http.ResponseWriter) error
}

type ListBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListBrokenMetadata200JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadata400JSONResponse ErrorResponse

func (response ListBrokenMetadata400JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploadedRequestObject struct {
}

type ListFilesNotUploadedResponseObject interface {
	VisitListFilesNotUploadedResponse(w http.ResponseWriter) error
}

type ListFilesNotUploaded200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListFilesNotUploaded200JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploaded400JSONResponse ErrorResponse

func (response ListFilesNotUploaded400JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFilesRequestObject struct {
}

type ListOrphanedFilesResponseObject interface {
	VisitListOrphanedFilesResponse(w http.ResponseWriter) error
}

type ListOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response ListOrphanedFiles200JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFiles400JSONResponse ErrorResponse

func (response ListOrphanedFiles400JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse VersionInformation

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(ctx context.Context, request UploadFilesRequestObject) (UploadFilesResponseObject, error)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(ctx context.Context, request DeleteFileRequestObject) (DeleteFileResponseObject, error)
	// Download file
	// (GET /files/{id})
	GetFile(ctx context.Context, request GetFileRequestObject) (GetFileResponseObject, error)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(ctx context.Context, request GetFileMetadataHeadersRequestObject) (GetFileMetadataHeadersResponseObject, error)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(ctx context.Context, request ReplaceFileRequestObject) (ReplaceFileResponseObject, error)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(ctx context.Context, request GetFilePresignedURLRequestObject) (GetFilePresignedURLResponseObject, error)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetPresignedURLContents(ctx context.Context, request GetPresignedURLContentsRequestObject) (GetPresignedURLContentsResponseObject, error)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx context.Context, request GetOpenAPISpecRequestObject) (GetOpenAPISpecResponseObject, error)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(ctx context.Context, request DeleteBrokenMetadataRequestObject) (DeleteBrokenMetadataResponseObject, error)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(ctx context.Context, request DeleteOrphanedFilesRequestObject) (DeleteOrphanedFilesResponseObject, error)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(ctx context.Context, request ListBrokenMetadataRequestObject) (ListBrokenMetadataResponseObject, error)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(ctx context.Context, request ListFilesNotUploadedRequestObject) (ListFilesNotUploadedResponseObject, error)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(ctx context.Context, request ListOrphanedFilesRequestObject) (ListOrphanedFilesResponseObject, error)
	// Get service version information
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadFiles operation middleware
func (sh *strictHandler) UploadFiles(ctx *gin.Context) {
	var request UploadFilesRequestObject

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadFiles(ctx, request.(UploadFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadFilesResponseObject); ok {
		if err := validResponse.VisitUploadFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFile operation middleware
func (sh *strictHandler) DeleteFile(ctx *gin.Context, id string) {
	var request DeleteFileRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFile(ctx, request.(DeleteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteFileResponseObject); ok {
		if err := validResponse.VisitDeleteFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFile operation middleware
func (sh *strictHandler) GetFile(ctx *gin.Context, id string, params GetFileParams) {
	var request GetFileRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFile(ctx, request.(GetFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileResponseObject); ok {
		if err := validResponse.VisitGetFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileMetadataHeaders operation middleware
func (sh *strictHandler) GetFileMetadataHeaders(ctx *gin.Context, id string, params GetFileMetadataHeadersParams) {
	var request GetFileMetadataHeadersRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileMetadataHeaders(ctx, request.(GetFileMetadataHeadersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileMetadataHeaders")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileMetadataHeadersResponseObject); ok {
		if err := validResponse.VisitGetFileMetadataHeadersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReplaceFile operation middleware
func (sh *strictHandler) ReplaceFile(ctx *gin.Context, id string) {
	var request ReplaceFileRequestObject

	request.Id = id

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ReplaceFile(ctx, request.(ReplaceFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReplaceFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ReplaceFileResponseObject); ok {
		if err := validResponse.VisitReplaceFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFilePresignedURL operation middleware
func (sh *strictHandler) GetFilePresignedURL(ctx *gin.Context, id string) {
	var request GetFilePresignedURLRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFilePresignedURL(ctx, request.(GetFilePresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFilePresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFilePresignedURLResponseObject); ok {
		if err := validResponse.VisitGetFilePresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPresignedURLContents operation middleware
func (sh *strictHandler) GetPresignedURLContents(ctx *gin.Context, id string, params GetPresignedURLContentsParams) {
	var request GetPresignedURLContentsRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPresignedURLContents(ctx, request.(GetPresignedURLContentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPresignedURLContents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPresignedURLContentsResponseObject); ok {
		if err := validResponse.VisitGetPresignedURLContentsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOpenAPISpec operation middleware
func (sh *strictHandler) GetOpenAPISpec(ctx *gin.Context) {
	var request GetOpenAPISpecRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetOpenAPISpec(ctx, request.(GetOpenAPISpecRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOpenAPISpec")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetOpenAPISpecResponseObject); ok {
		if err := validResponse.VisitGetOpenAPISpecResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBrokenMetadata operation middleware
func (sh *strictHandler) DeleteBrokenMetadata(ctx *gin.Context) {
	var request DeleteBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBrokenMetadata(ctx, request.(DeleteBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitDeleteBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteOrphanedFiles operation middleware
func (sh *strictHandler) DeleteOrphanedFiles(ctx *gin.Context) {
	var request DeleteOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteOrphanedFiles(ctx, request.(DeleteOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitDeleteOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBrokenMetadata operation middleware
func (sh *strictHandler) ListBrokenMetadata(ctx *gin.Context) {
	var request ListBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListBrokenMetadata(ctx, request.(ListBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitListBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFilesNotUploaded operation middleware
func (sh *strictHandler) ListFilesNotUploaded(ctx *gin.Context) {
	var request ListFilesNotUploadedRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListFilesNotUploaded(ctx, request.(ListFilesNotUploadedRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFilesNotUploaded")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListFilesNotUploadedResponseObject); ok {
		if err := validResponse.VisitListFilesNotUploadedResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListOrphanedFiles operation middleware
func (sh *strictHandler) ListOrphanedFiles(ctx *gin.Context) {
	var request ListOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListOrphanedFiles(ctx, request.(ListOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitListOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(ctx *gin.Context) {
	var request GetVersionRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(c *gin.Context)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(c *gin.Context, id string)
	// Download file
	// (GET /files/{id})
	GetFile(c *gin.Context, id string, params GetFileParams)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(c *gin.Context, id string, params GetFileMetadataHeadersParams)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(c *gin.Context, id string)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetPresignedURL(c *gin.Context, id string)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetPresignedURLContents(c *gin.Context, id string, params GetPresignedURLContentsParams)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(c *gin.Context)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(c *gin.Context)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(c *gin.Context)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(c *gin.Context)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(c *gin.Context)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(c *gin.Context)
	// Get service version information
	// (GET /version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadFiles operation middleware
func (siw *ServerInterfaceWrapper) UploadFiles(c *gin.Context) {

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadFiles(c)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteFile(c, id)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFile(c, id, params)
}

// GetFileMetadataHeaders operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadataHeaders(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileMetadataHeadersParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince time.Time
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileMetadataHeaders(c, id, params)
}

// ReplaceFile operation middleware
func (siw *ServerInterfaceWrapper) ReplaceFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReplaceFile(c, id)
}

// GetPresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetPresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPresignedURL(c, id)
}

// GetPresignedURLContents operation middleware
func (siw *ServerInterfaceWrapper) GetPresignedURLContents(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPresignedURLContentsParams

	// ------------- Required query parameter "X-Amz-Algorithm" -------------

	if paramValue := c.Query("X-Amz-Algorithm"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Algorithm is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Algorithm", c.Request.URL.Query(), &params.XAmzAlgorithm)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Algorithm: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Credential" -------------

	if paramValue := c.Query("X-Amz-Credential"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Credential is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Credential", c.Request.URL.Query(), &params.XAmzCredential)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Credential: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Date" -------------

	if paramValue := c.Query("X-Amz-Date"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Date is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Date", c.Request.URL.Query(), &params.XAmzDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Expires" -------------

	if paramValue := c.Query("X-Amz-Expires"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Expires is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Expires", c.Request.URL.Query(), &params.XAmzExpires)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Expires: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Signature" -------------

	if paramValue := c.Query("X-Amz-Signature"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Signature is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Signature", c.Request.URL.Query(), &params.XAmzSignature)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Signature: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-SignedHeaders" -------------

	if paramValue := c.Query("X-Amz-SignedHeaders"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-SignedHeaders is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-SignedHeaders", c.Request.URL.Query(), &params.XAmzSignedHeaders)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-SignedHeaders: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPresignedURLContents(c, id, params)
}

// GetOpenAPISpec operation middleware
func (siw *ServerInterfaceWrapper) GetOpenAPISpec(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenAPISpec(c)
}

// DeleteBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBrokenMetadata(c)
}

// DeleteOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) DeleteOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteOrphanedFiles(c)
}

// ListBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) ListBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListBrokenMetadata(c)
}

// ListFilesNotUploaded operation middleware
func (siw *ServerInterfaceWrapper) ListFilesNotUploaded(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListFilesNotUploaded(c)
}

// ListOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) ListOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListOrphanedFiles(c)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/files/", wrapper.UploadFiles)
	router.DELETE(options.BaseURL+"/files/:id", wrapper.DeleteFile)
	router.GET(options.BaseURL+"/files/:id", wrapper.GetFile)
	router.HEAD(options.BaseURL+"/files/:id", wrapper.GetFileMetadataHeaders)
	router.PUT(options.BaseURL+"/files/:id", wrapper.ReplaceFile)
	router.GET(options.BaseURL+"/files/:id/presignedurl", wrapper.GetPresignedURL)
	router.GET(options.BaseURL+"/files/:id/presignedurl/contents", wrapper.GetPresignedURLContents)
	router.GET(options.BaseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.POST(options.BaseURL+"/ops/delete-broken-metadata", wrapper.DeleteBrokenMetadata)
	router.POST(options.BaseURL+"/ops/delete-orphans", wrapper.DeleteOrphanedFiles)
	router.POST(options.BaseURL+"/ops/list-broken-metadata", wrapper.ListBrokenMetadata)
	router.POST(options.BaseURL+"/ops/list-not-uploaded", wrapper.ListFilesNotUploaded)
	router.POST(options.BaseURL+"/ops/list-orphans", wrapper.ListOrphanedFiles)
	router.GET(options.BaseURL+"/version", wrapper.GetVersion)
}

type UploadFilesRequestObject struct {
	Body *multipart.Reader
}

type UploadFilesResponseObject interface {
	VisitUploadFilesResponse(w http.ResponseWriter) error
}

type UploadFiles201JSONResponse struct {
	// ProcessedFiles List of successfully processed files with their metadata.
	ProcessedFiles []FileMetadata `json:"processedFiles"`
}

func (response UploadFiles201JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadFilesdefaultJSONResponse struct {
	Body       ErrorResponseWithProcessedFiles
	StatusCode int
}

func (response UploadFilesdefaultJSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteFileRequestObject struct {
	Id string `json:"id"`
}

type DeleteFileResponseObject interface {
	VisitDeleteFileResponse(w http.ResponseWriter) error
}

type DeleteFile204Response struct {
}

func (response DeleteFile204Response) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteFile400JSONResponse ErrorResponse

func (response DeleteFile400JSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetFileRequestObject struct {
	Id     string `json:"id"`
	Params GetFileParams
}

type GetFileResponseObject interface {
	VisitGetFileResponse(w http.ResponseWriter) error
}

type GetFile200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile200ResponseHeaders
	ContentLength int64
}

func (response GetFile200ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile206ResponseHeaders
	ContentLength int64
}

func (response GetFile206ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile304Response struct {
	Headers GetFile304ResponseHeaders
}

func (response GetFile304Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFile400ResponseHeaders struct {
	XError string
}

type GetFile400Response struct {
	Headers GetFile400ResponseHeaders
}

func (response GetFile400Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(400)
	return nil
}

type GetFile412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile412Response struct {
	Headers GetFile412ResponseHeaders
}

func (response GetFile412Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileMetadataHeadersRequestObject struct {
	Id     string `json:"id"`
	Params GetFileMetadataHeadersParams
}

type GetFileMetadataHeadersResponseObject interface {
	VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error
}

type GetFileMetadataHeaders200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentLength      int
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileMetadataHeaders200Response struct {
	Headers GetFileMetadataHeaders200ResponseHeaders
}

func (response GetFileMetadataHeaders200Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)
	return nil
}

type GetFileMetadataHeaders304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders304Response struct {
	Headers GetFileMetadataHeaders304ResponseHeaders
}

func (response GetFileMetadataHeaders304Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileMetadataHeaders412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders412Response struct {
	Headers GetFileMetadataHeaders412ResponseHeaders
}

func (response GetFileMetadataHeaders412Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileMetadataHeadersdefaultResponseHeaders struct {
	XError string
}

type GetFileMetadataHeadersdefaultResponse struct {
	Headers GetFileMetadataHeadersdefaultResponseHeaders

	StatusCode int
}

func (response GetFileMetadataHeadersdefaultResponse) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type ReplaceFileRequestObject struct {
	Id   string `json:"id"`
	Body *multipart.Reader
}

type ReplaceFileResponseObject interface {
	VisitReplaceFileResponse(w http.ResponseWriter) error
}

type ReplaceFile200JSONResponse FileMetadata

func (response ReplaceFile200JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ReplaceFile400JSONResponse ErrorResponse

func (response ReplaceFile400JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetPresignedURLRequestObject struct {
	Id string `json:"id"`
}

type GetPresignedURLResponseObject interface {
	VisitGetPresignedURLResponse(w http.ResponseWriter) error
}

type GetPresignedURL200JSONResponse PresignedURLResponse

func (response GetPresignedURL200JSONResponse) VisitGetPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPresignedURL400JSONResponse ErrorResponse

func (response GetPresignedURL400JSONResponse) VisitGetPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetPresignedURLContentsRequestObject struct {
	Id     string `json:"id"`
	Params GetPresignedURLContentsParams
}

type GetPresignedURLContentsResponseObject interface {
	VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error
}

type GetPresignedURLContents200ResponseHeaders struct {
	AcceptRanges  string
	CacheControl  string
	ContentLength float32
	ContentType   string
	Etag          string
	LastModified  string
}

type GetPresignedURLContents200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetPresignedURLContents200ResponseHeaders
	ContentLength int64
}

func (response GetPresignedURLContents200ApplicationoctetStreamResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetPresignedURLContents206ResponseHeaders struct {
	AcceptRanges  string
	CacheControl  string
	ContentLength float32
	ContentRange  string
	ContentType   string
	Etag          string
	LastModified  string
}

type GetPresignedURLContents206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetPresignedURLContents206ResponseHeaders
	ContentLength int64
}

func (response GetPresignedURLContents206ApplicationoctetStreamResponse) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetPresignedURLContents304ResponseHeaders struct {
	CacheControl  string
	ContentLength float32
	ContentType   string
	Etag          string
	LastModified  string
}

type GetPresignedURLContents304Response struct {
	Headers GetPresignedURLContents304ResponseHeaders
}

func (response GetPresignedURLContents304Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.WriteHeader(304)
	return nil
}

type GetPresignedURLContents400ResponseHeaders struct {
	XError string
}

type GetPresignedURLContents400Response struct {
	Headers GetPresignedURLContents400ResponseHeaders
}

func (response GetPresignedURLContents400Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(400)
	return nil
}

type GetPresignedURLContents412ResponseHeaders struct {
	CacheControl  string
	ContentLength float32
	ContentType   string
	Etag          string
	LastModified  string
}

type GetPresignedURLContents412Response struct {
	Headers GetPresignedURLContents412ResponseHeaders
}

func (response GetPresignedURLContents412Response) VisitGetPresignedURLContentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.WriteHeader(412)
	return nil
}

type GetOpenAPISpecRequestObject struct {
}

type GetOpenAPISpecResponseObject interface {
	VisitGetOpenAPISpecResponse(w http.ResponseWriter) error
}

type GetOpenAPISpec200ApplicationxYamlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetOpenAPISpec200ApplicationxYamlResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/x-yaml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBrokenMetadataRequestObject struct {
}

type DeleteBrokenMetadataResponseObject interface {
	VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error
}

type DeleteBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response DeleteBrokenMetadata200JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBrokenMetadata400JSONResponse ErrorResponse

func (response DeleteBrokenMetadata400JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFilesRequestObject struct {
}

type DeleteOrphanedFilesResponseObject interface {
	VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error
}

type DeleteOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response DeleteOrphanedFiles200JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFiles400JSONResponse ErrorResponse

func (response DeleteOrphanedFiles400JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadataRequestObject struct {
}

type ListBrokenMetadataResponseObject interface {
	VisitListBrokenMetadataResponse(w http.ResponseWriter) error
}

type ListBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListBrokenMetadata200JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadata400JSONResponse ErrorResponse

func (response ListBrokenMetadata400JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploadedRequestObject struct {
}

type ListFilesNotUploadedResponseObject interface {
	VisitListFilesNotUploadedResponse(w http.ResponseWriter) error
}

type ListFilesNotUploaded200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListFilesNotUploaded200JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploaded400JSONResponse ErrorResponse

func (response ListFilesNotUploaded400JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFilesRequestObject struct {
}

type ListOrphanedFilesResponseObject interface {
	VisitListOrphanedFilesResponse(w http.ResponseWriter) error
}

type ListOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response ListOrphanedFiles200JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFiles400JSONResponse ErrorResponse

func (response ListOrphanedFiles400JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse VersionInformation

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload files
	// (POST /files/)
	UploadFiles(ctx context.Context, request UploadFilesRequestObject) (UploadFilesResponseObject, error)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(ctx context.Context, request DeleteFileRequestObject) (DeleteFileResponseObject, error)
	// Download file
	// (GET /files/{id})
	GetFile(ctx context.Context, request GetFileRequestObject) (GetFileResponseObject, error)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(ctx context.Context, request GetFileMetadataHeadersRequestObject) (GetFileMetadataHeadersResponseObject, error)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(ctx context.Context, request ReplaceFileRequestObject) (ReplaceFileResponseObject, error)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetPresignedURL(ctx context.Context, request GetPresignedURLRequestObject) (GetPresignedURLResponseObject, error)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetPresignedURLContents(ctx context.Context, request GetPresignedURLContentsRequestObject) (GetPresignedURLContentsResponseObject, error)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx context.Context, request GetOpenAPISpecRequestObject) (GetOpenAPISpecResponseObject, error)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(ctx context.Context, request DeleteBrokenMetadataRequestObject) (DeleteBrokenMetadataResponseObject, error)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(ctx context.Context, request DeleteOrphanedFilesRequestObject) (DeleteOrphanedFilesResponseObject, error)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(ctx context.Context, request ListBrokenMetadataRequestObject) (ListBrokenMetadataResponseObject, error)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(ctx context.Context, request ListFilesNotUploadedRequestObject) (ListFilesNotUploadedResponseObject, error)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(ctx context.Context, request ListOrphanedFilesRequestObject) (ListOrphanedFilesResponseObject, error)
	// Get service version information
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadFiles operation middleware
func (sh *strictHandler) UploadFiles(ctx *gin.Context) {
	var request UploadFilesRequestObject

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadFiles(ctx, request.(UploadFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadFilesResponseObject); ok {
		if err := validResponse.VisitUploadFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFile operation middleware
func (sh *strictHandler) DeleteFile(ctx *gin.Context, id string) {
	var request DeleteFileRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFile(ctx, request.(DeleteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteFileResponseObject); ok {
		if err := validResponse.VisitDeleteFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFile operation middleware
func (sh *strictHandler) GetFile(ctx *gin.Context, id string, params GetFileParams) {
	var request GetFileRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFile(ctx, request.(GetFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileResponseObject); ok {
		if err := validResponse.VisitGetFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileMetadataHeaders operation middleware
func (sh *strictHandler) GetFileMetadataHeaders(ctx *gin.Context, id string, params GetFileMetadataHeadersParams) {
	var request GetFileMetadataHeadersRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileMetadataHeaders(ctx, request.(GetFileMetadataHeadersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileMetadataHeaders")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileMetadataHeadersResponseObject); ok {
		if err := validResponse.VisitGetFileMetadataHeadersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReplaceFile operation middleware
func (sh *strictHandler) ReplaceFile(ctx *gin.Context, id string) {
	var request ReplaceFileRequestObject

	request.Id = id

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ReplaceFile(ctx, request.(ReplaceFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReplaceFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ReplaceFileResponseObject); ok {
		if err := validResponse.VisitReplaceFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPresignedURL operation middleware
func (sh *strictHandler) GetPresignedURL(ctx *gin.Context, id string) {
	var request GetPresignedURLRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPresignedURL(ctx, request.(GetPresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPresignedURLResponseObject); ok {
		if err := validResponse.VisitGetPresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPresignedURLContents operation middleware
func (sh *strictHandler) GetPresignedURLContents(ctx *gin.Context, id string, params GetPresignedURLContentsParams) {
	var request GetPresignedURLContentsRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPresignedURLContents(ctx, request.(GetPresignedURLContentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPresignedURLContents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPresignedURLContentsResponseObject); ok {
		if err := validResponse.VisitGetPresignedURLContentsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOpenAPISpec operation middleware
func (sh *strictHandler) GetOpenAPISpec(ctx *gin.Context) {
	var request GetOpenAPISpecRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetOpenAPISpec(ctx, request.(GetOpenAPISpecRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOpenAPISpec")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetOpenAPISpecResponseObject); ok {
		if err := validResponse.VisitGetOpenAPISpecResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBrokenMetadata operation middleware
func (sh *strictHandler) DeleteBrokenMetadata(ctx *gin.Context) {
	var request DeleteBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBrokenMetadata(ctx, request.(DeleteBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitDeleteBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteOrphanedFiles operation middleware
func (sh *strictHandler) DeleteOrphanedFiles(ctx *gin.Context) {
	var request DeleteOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteOrphanedFiles(ctx, request.(DeleteOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitDeleteOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBrokenMetadata operation middleware
func (sh *strictHandler) ListBrokenMetadata(ctx *gin.Context) {
	var request ListBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListBrokenMetadata(ctx, request.(ListBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitListBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFilesNotUploaded operation middleware
func (sh *strictHandler) ListFilesNotUploaded(ctx *gin.Context) {
	var request ListFilesNotUploadedRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListFilesNotUploaded(ctx, request.(ListFilesNotUploadedRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFilesNotUploaded")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListFilesNotUploadedResponseObject); ok {
		if err := validResponse.VisitListFilesNotUploadedResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListOrphanedFiles operation middleware
func (sh *strictHandler) ListOrphanedFiles(ctx *gin.Context) {
	var request ListOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListOrphanedFiles(ctx, request.(ListOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitListOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(ctx *gin.Context) {
	var request GetVersionRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
